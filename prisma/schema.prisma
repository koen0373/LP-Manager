// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id            String     @id @default(cuid())
  email         String?    @unique
  state         UserState  @default(WAITLIST)
  poolAllowance Int        @default(0)
  activatedAt   DateTime?
  createdAt     DateTime   @default(now())
  updatedAt     DateTime   @updatedAt

  wallets   Wallet[]
  payments  Payment[]
}

model PoolEvent {
  id           String   @id // txHash:logIndex
  pool         String   // pool address (checksummed lower-case)
  blockNumber  Int
  txHash       String
  logIndex     Int
  timestamp    Int
  eventName    String   // 'Mint' | 'Burn' | 'Swap' | 'Collect' | 'Flash' ...
  // Common decoded fields (NULLABLE; gebruik per event)
  sender       String?
  owner        String?
  recipient    String?
  tickLower    Int?
  tickUpper    Int?
  amount       String?  // uint128/liquidity (for Mint/Burn)
  amount0      String?
  amount1      String?
  sqrtPriceX96 String?
  liquidity    String?
  tick         Int?

  // dedupe guard
  @@unique([txHash, logIndex])
  @@index([pool, blockNumber])
}

model WaitlistEntry {
  id         String   @id @default(cuid())
  email      String
  wallet     String?
  fastTrack  Boolean  @default(false)
  message    String?
  createdAt  DateTime @default(now())

  @@unique([email])
}

enum PositionEventType {
  MINT
  INCREASE
  DECREASE
  COLLECT
  BURN
  SWAP
  OTHER
}

model PositionEvent {
  id             String             @id // txHash:logIndex
  tokenId        String
  pool           String
  blockNumber    Int
  txHash         String
  logIndex       Int
  timestamp      Int
  eventType      PositionEventType
  sender         String?
  owner          String?
  recipient      String?
  tickLower      Int?
  tickUpper      Int?
  tick           Int?
  liquidityDelta String?
  amount0        String?
  amount1        String?
  sqrtPriceX96   String?
  price1Per0     Float?
  usdValue       Float?
  metadata       Json?

  @@unique([txHash, logIndex])
  @@index([tokenId, blockNumber])
  @@index([pool, blockNumber])
}

model PositionTransfer {
  id          String @id // txHash:logIndex
  tokenId     String
  from        String
  to          String
  blockNumber Int
  txHash      String
  logIndex    Int
  timestamp   Int
  metadata    Json?

  @@unique([txHash, logIndex])
  @@index([tokenId, blockNumber])
}

enum CapitalFlowType {
  DEPOSIT
  WITHDRAW
  FEES_REALIZED
  FEES_REINVESTED
  TRANSFER
  OTHER
}

enum PoolStatus {
  ACTIVE
  INACTIVE
  ARCHIVED
}

enum PaymentStatus {
  PENDING
  PAID
  FAILED
}

enum PaymentKind {
  FAST_FORWARD
}

enum UserState {
  WAITLIST
  ACTIVATED
}

model CapitalFlow {
  id          String           @id
  wallet      String
  tokenId     String?
  pool        String?
  flowType    CapitalFlowType
  amountUsd   Float
  amount0     String?
  amount1     String?
  timestamp   Int
  txHash      String
  relatedTx   String?
  metadata    Json?
  createdAt   DateTime         @default(now())
  updatedAt   DateTime         @updatedAt

  @@index([wallet, timestamp])
  @@index([tokenId, timestamp])
  @@index([pool, timestamp])
}

model Wallet {
  id               Int        @id @default(autoincrement())
  userId           String
  address          String
  billingStartedAt DateTime   @default(now())
  billingExpiresAt DateTime   @default(now())
  createdAt        DateTime   @default(now())
  updatedAt        DateTime   @updatedAt

  user     User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  pools    UserPool[]

  @@unique([userId, address])
  @@index([billingExpiresAt])
}

model UserPool {
  id                  Int        @id @default(autoincrement())
  walletId            Int
  poolId              String
  provider            String
  status              PoolStatus @default(ACTIVE)
  excludedFromBilling Boolean    @default(false)
  lastActivity        DateTime?
  createdAt           DateTime   @default(now())
  updatedAt           DateTime   @updatedAt

  wallet Wallet @relation(fields: [walletId], references: [id], onDelete: Cascade)

  @@unique([walletId, poolId])
  @@index([walletId, status])
}

model Payment {
  id                 Int            @id @default(autoincrement())
  userId             String
  provider           String         @default("crypto")
  chainId            Int
  tokenAddress       String
  treasuryAddress    String
  amountUsd          Float
  amountToken        Float
  txHash             String?
  intentId           String         @unique
  expiresAt          DateTime?
  payerAddress       String?
  kind               PaymentKind    @default(FAST_FORWARD)
  status             PaymentStatus  @default(PENDING)
  disclaimerAccepted Boolean        @default(false)
  approvedBy         String?
  approvedAt         DateTime?
  invoiceNumber      String?
  invoiceIssuedAt    DateTime?
  invoiceCsv         String?
  invoiceSentAt      DateTime?
  createdAt          DateTime       @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, createdAt])
}

// Indexer checkpoint tracking
model SyncCheckpoint {
  id             String   @id // source:key (e.g., "NPM:global" or "NPM:tokenId:22003")
  source         String   // "NPM" | "POOL" | etc
  key            String   // "global" | "tokenId:22003" | "pool:0x..."
  lastBlock      Int      // Last fully synced block
  lastTimestamp  Int?     // Block timestamp (for reference)
  eventsCount    Int      @default(0) // Total events synced
  updatedAt      DateTime @updatedAt
  createdAt      DateTime @default(now())

  @@unique([source, key])
  @@index([source, lastBlock])
}

// Backfill checkpoint per tokenId (LP position)
model BackfillCursor {
  tokenId        Int      @id
  lastBlock      Int      @default(0)
  lastFetchedAt  DateTime @default(now())
  updatedAt      DateTime @updatedAt
  createdAt      DateTime @default(now())

  @@index([lastBlock])
}

model PlaceholderSignup {
  id        String   @id @default(cuid())
  email     String   @unique
  createdAt DateTime @default(now())
}
